# 架构优化总结

## 一、已完成的工作

### 1.1 Git 配置
- ✅ 创建 `.gitignore` 文件，忽略 `target` 文件夹和其他构建产物

### 1.2 环境配置
- ✅ 创建 `application-dev.properties`（开发环境，连接远程服务器 8.134.198.179）
- ✅ 创建 `application-prod.properties`（生产环境，连接本地服务器 127.0.0.1）
- ✅ 配置 Spring Profile 激活机制

### 1.3 Redis 集成
- ✅ 添加 Redis 依赖到 `pom.xml`
- ✅ 创建 `RedisConfig` 配置类，配置 Redis 序列化方式
- ✅ 创建 `RedisCacheUtil` 工具类，实现缓存操作

### 1.4 线程池优化
- ✅ 创建 `ThreadPoolConfig` 配置类
- ✅ 配置异步任务线程池（核心线程数：CPU核心数+1，最大线程数：核心线程数*2）
- ✅ 配置缓存刷新线程池（独立线程池，避免影响主业务）
- ✅ 配置邮件发送线程池（独立线程池）

### 1.5 布隆过滤器
- ✅ 创建 `BloomFilterUtil` 工具类
- ✅ 实现文章、用户、评论等业务模块的布隆过滤器
- ✅ 支持动态创建业务模块的布隆过滤器

### 1.6 缓存防护机制
- ✅ **缓存雪崩防护**：使用随机过期时间，避免大量缓存同时过期
- ✅ **缓存穿透防护**：结合布隆过滤器和空对象缓存
- ✅ **缓存击穿防护**：使用分布式锁（Redis SETNX），防止热点数据过期时大量并发请求

### 1.7 分布式缓存架构
- ✅ 创建 `CacheService` 接口和 `CacheServiceImpl` 实现类
- ✅ 实现缓存分层架构设计（L1: 本地缓存，L2: Redis，L3: 数据库）
- ✅ 创建 `PoetryCacheRedisAdapter` 适配器，平滑迁移现有代码

### 1.8 文档
- ✅ 创建 `Redis事务vs数据库事务.md` 说明文档
- ✅ 创建 `缓存迁移指南.md` 迁移文档
- ✅ 创建 `架构优化总结.md` 总结文档

## 二、技术要点

### 2.1 Java 线程池优化

#### 参数设计原则
1. **核心线程数（corePoolSize）**
   - CPU 密集型：N + 1（N 为 CPU 核心数）
   - IO 密集型：2N
   - 本项目采用：CPU核心数 + 1

2. **最大线程数（maxPoolSize）**
   - 设置为核心线程数的 2 倍
   - 根据业务并发量调整

3. **队列容量（queueCapacity）**
   - 防止任务堆积导致内存溢出
   - 本项目设置为 200

4. **拒绝策略（rejectionPolicy）**
   - `CallerRunsPolicy`：由调用线程执行任务
   - 其他策略：`AbortPolicy`（抛异常）、`DiscardPolicy`（丢弃）、`DiscardOldestPolicy`（丢弃最老）

#### 线程池设计
- **异步任务线程池**：处理通用异步任务
- **缓存刷新线程池**：独立处理缓存刷新，避免影响主业务
- **邮件发送线程池**：独立处理邮件发送

### 2.2 Redis 持久化策略

#### RDB（Redis Database）
- **优点**：文件小，恢复快，适合备份
- **缺点**：可能丢失最后一次快照后的数据
- **配置**：`save 900 1`（900秒内至少1个key变化时保存）

#### AOF（Append Only File）
- **优点**：数据更安全，最多丢失1秒数据
- **缺点**：文件大，恢复慢
- **配置**：`appendfsync everysec`（每秒同步一次）

#### 最佳实践
- **开发环境**：RDB + AOF，数据安全优先
- **生产环境**：RDB + AOF，平衡性能和数据安全

### 2.3 布隆过滤器 vs 缓存空对象 vs 互斥锁

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **布隆过滤器** | 空间占用小，查询快 | 存在误判率 | 大规模数据，快速过滤 |
| **缓存空对象** | 实现简单 | 占用缓存空间 | 小规模数据，简单场景 |
| **互斥锁** | 保证数据一致性 | 可能造成线程阻塞 | 热点数据，防止击穿 |

**最佳实践**：结合使用
1. 布隆过滤器：第一层防护，快速过滤不存在的请求
2. 缓存空对象：第二层防护，减少数据库查询
3. 互斥锁：第三层防护，防止缓存击穿

### 2.4 缓存雪崩、穿透、击穿

#### 缓存雪崩（Cache Avalanche）
- **问题**：大量缓存同时过期，导致大量请求直接访问数据库
- **解决方案**：
  1. 设置随机过期时间，避免同时过期
  2. 使用多级缓存（本地缓存 + Redis）
  3. 缓存预热，提前加载热点数据

#### 缓存穿透（Cache Penetration）
- **问题**：查询不存在的数据，绕过缓存直接访问数据库
- **解决方案**：
  1. 布隆过滤器：快速判断数据是否存在
  2. 缓存空对象：将空结果也缓存，设置较短过期时间
  3. 参数校验：对请求参数进行校验，过滤无效请求

#### 缓存击穿（Cache Breakdown）
- **问题**：热点数据过期，大量并发请求同时访问数据库
- **解决方案**：
  1. 互斥锁：使用分布式锁，只允许一个线程查询数据库
  2. 永不过期：热点数据设置永不过期，异步更新
  3. 逻辑过期：设置逻辑过期时间，后台异步刷新

### 2.5 分布式缓存架构设计

#### 缓存分层
1. **L1: 本地缓存**（Caffeine/Guava Cache）
   - 热点数据，快速访问
   - 单机内存，速度快

2. **L2: Redis 缓存**
   - 分布式共享缓存
   - 支持多实例共享

3. **L3: 数据库**
   - 持久化存储
   - 数据源

#### 缓存更新策略
1. **Cache Aside（旁路缓存）**
   - 先更新数据库，再删除缓存
   - 适合读多写少场景

2. **Write Through（写透）**
   - 先更新缓存，再更新数据库
   - 保证缓存和数据库一致

3. **Write Back（写回）**
   - 先更新缓存，异步更新数据库
   - 性能最好，但可能丢失数据

#### 缓存一致性
- **最终一致性**：允许短暂不一致，通过过期时间保证最终一致
- **强一致性**：使用分布式锁保证读写一致性

### 2.6 Redis 事务 vs 数据库事务

| 特性 | Redis 事务 | 数据库事务 |
|------|-----------|-----------|
| **原子性** | ✅ 支持 | ✅ 支持 |
| **一致性** | ⚠️ 部分支持 | ✅ 完全支持 |
| **隔离性** | ✅ 支持 | ✅ 支持（多级别） |
| **持久性** | ⚠️ 取决于持久化策略 | ✅ 完全支持 |
| **回滚** | ❌ 不支持 | ✅ 支持 |
| **性能** | ⚡ 高（内存操作） | 🐌 相对较低（磁盘 I/O） |

**使用建议**：
- Redis 事务：适合高并发、简单操作、不需要回滚的场景
- 数据库事务：适合复杂业务逻辑、数据一致性要求高、需要回滚的场景
- 混合使用：在实际项目中，通常结合使用 Redis 和数据库事务

## 三、使用指南

### 3.1 环境切换

```bash
# 开发环境（默认）
spring.profiles.active=dev

# 生产环境
spring.profiles.active=prod
```

### 3.2 缓存使用

```java
// 方式一：使用适配器（平滑迁移）
@Autowired
private PoetryCacheRedisAdapter cacheAdapter;
cacheAdapter.put("key", value, 3600);

// 方式二：使用 RedisCacheUtil（推荐，功能强大）
@Autowired
private RedisCacheUtil redisCacheUtil;
redisCacheUtil.set("key", value, 3600);

// 方式三：使用 CacheService（面向接口）
@Autowired
private CacheService cacheService;
cacheService.set("key", value, 3600);
```

### 3.3 异步任务

```java
@Async("asyncExecutor")
public void asyncMethod() {
    // 异步执行
}
```

### 3.4 布隆过滤器

```java
@Autowired
private BloomFilterUtil bloomFilterUtil;

// 添加数据
bloomFilterUtil.addArticleId("123");

// 判断是否存在
if (bloomFilterUtil.mightContainArticleId("123")) {
    // 可能存在
}
```

## 四、性能优化建议

1. **合理设置过期时间**：避免缓存雪崩
2. **使用布隆过滤器**：防止缓存穿透
3. **缓存预热**：系统启动时加载热点数据
4. **监控缓存命中率**：及时发现问题
5. **合理使用线程池**：避免线程资源耗尽

## 五、后续优化方向

1. **本地缓存**：引入 Caffeine 作为 L1 缓存
2. **缓存监控**：集成 Redis 监控工具，实时监控缓存状态
3. **缓存预热**：实现自动缓存预热机制
4. **缓存降级**：实现缓存不可用时的降级策略
5. **分布式锁优化**：使用 Redisson 实现更完善的分布式锁

## 六、注意事项

1. **Redis 连接**：确保 Redis 服务已启动并可访问
2. **序列化**：Redis 使用 JSON 序列化，确保对象可序列化
3. **过期时间**：Redis 不支持永不过期（0），适配器会自动转换为30天
4. **性能**：`values()` 和 `size()` 方法在 Redis 中性能较低，不建议频繁调用
5. **布隆过滤器**：首次查询数据后，会自动添加到布隆过滤器

