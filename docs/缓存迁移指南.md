# 缓存迁移指南：从 PoetryCache 迁移到 Redis

## 一、迁移概述

本项目已从内存缓存（PoetryCache）迁移到 Redis 分布式缓存，提供了更好的性能和可扩展性。

## 二、新增功能

### 2.1 缓存防护机制

1. **缓存雪崩防护**：使用随机过期时间，避免大量缓存同时过期
2. **缓存穿透防护**：结合布隆过滤器和空对象缓存
3. **缓存击穿防护**：使用分布式锁，防止热点数据过期时大量并发请求

### 2.2 线程池优化

- 异步任务线程池：处理异步任务
- 缓存刷新线程池：独立处理缓存刷新
- 邮件发送线程池：处理邮件发送任务

### 2.3 布隆过滤器

- 快速判断数据是否存在
- 防止缓存穿透
- 支持多业务模块

## 三、迁移步骤

### 3.1 方式一：使用适配器（推荐，平滑迁移）

```java
// 原有代码
PoetryCache.put("key", value, 3600);
Object value = PoetryCache.get("key");

// 迁移后代码
@Autowired
private PoetryCacheRedisAdapter cacheAdapter;

cacheAdapter.put("key", value, 3600);
Object value = cacheAdapter.get("key");
```

### 3.2 方式二：直接使用 RedisCacheUtil（推荐，功能更强大）

```java
@Autowired
private RedisCacheUtil redisCacheUtil;

// 简单使用
redisCacheUtil.set("key", value, 3600);
Object value = redisCacheUtil.get("key");

// 高级使用（带防护机制）
Article article = redisCacheUtil.get(
    "article:" + id,
    "article",  // 模块名
    String.valueOf(id),  // 数据ID
    () -> articleMapper.selectById(id),  // 数据加载器
    3600  // 过期时间
);
```

### 3.3 方式三：使用 CacheService（推荐，面向接口）

```java
@Autowired
private CacheService cacheService;

cacheService.set("key", value, 3600);
Article article = cacheService.get("article:" + id, Article.class);
```

## 四、配置说明

### 4.1 开发环境配置（application-dev.properties）

```properties
# Redis 配置
spring.redis.host=8.134.198.179
spring.redis.port=6379
spring.redis.password=
```

### 4.2 生产环境配置（application-prod.properties）

```properties
# Redis 配置
spring.redis.host=127.0.0.1
spring.redis.port=6379
spring.redis.password=
```

## 五、使用示例

### 5.1 用户登录缓存

```java
// 原有代码
PoetryCache.put(CommonConst.USER_ACCESS_TOKEN + uuid, user, CommonConst.TOKEN_EXPIRE);

// 迁移后代码
@Autowired
private RedisCacheUtil redisCacheUtil;

redisCacheUtil.set(CommonConst.USER_ACCESS_TOKEN + uuid, user, CommonConst.TOKEN_EXPIRE);
```

### 5.2 文章查询（带防护机制）

```java
@Autowired
private RedisCacheUtil redisCacheUtil;

public ArticleVO getArticleById(Integer id) {
    String cacheKey = "article:" + id;
    
    // 使用高级方法，自动处理缓存穿透、击穿、雪崩
    Article article = redisCacheUtil.get(
        cacheKey,
        "article",  // 模块名，用于布隆过滤器
        String.valueOf(id),  // 数据ID
        () -> articleMapper.selectById(id),  // 数据加载器
        3600  // 过期时间（秒）
    );
    
    if (article == null) {
        return null;
    }
    
    // 将文章ID添加到布隆过滤器
    bloomFilterUtil.addArticleId(String.valueOf(id));
    
    return convertToVO(article);
}
```

### 5.3 缓存预热

```java
@Autowired
private CacheService cacheService;

@PostConstruct
public void warmUp() {
    // 系统启动时预热热点数据
    cacheService.warmUp();
}
```

## 六、注意事项

1. **Redis 连接**：确保 Redis 服务已启动并可访问
2. **序列化**：Redis 使用 JSON 序列化，确保对象可序列化
3. **过期时间**：Redis 不支持永不过期（0），适配器会自动转换为30天
4. **性能**：`values()` 和 `size()` 方法在 Redis 中性能较低，不建议频繁调用
5. **布隆过滤器**：首次查询数据后，会自动添加到布隆过滤器

## 七、性能对比

| 特性 | PoetryCache（内存） | Redis |
|------|-------------------|-------|
| 存储位置 | 单机内存 | 分布式内存 |
| 数据共享 | ❌ 不支持 | ✅ 支持 |
| 持久化 | ❌ 不支持 | ✅ 支持 |
| 性能 | ⚡ 极快 | ⚡ 快 |
| 扩展性 | ❌ 有限 | ✅ 高 |
| 防护机制 | ❌ 无 | ✅ 完整 |

## 八、回退方案

如果 Redis 不可用，可以通过配置回退到内存缓存：

```java
PoetryCacheRedisAdapter.setUseRedis(false);
```

## 九、最佳实践

1. **优先使用 RedisCacheUtil**：功能更强大，防护机制完善
2. **合理设置过期时间**：避免缓存雪崩
3. **使用布隆过滤器**：防止缓存穿透
4. **缓存预热**：系统启动时加载热点数据
5. **监控缓存命中率**：及时发现问题

